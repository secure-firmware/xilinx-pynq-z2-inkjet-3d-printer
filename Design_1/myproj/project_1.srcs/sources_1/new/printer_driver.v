module edge_detector (
    input wire clk,
    input wire rst,
    input wire signal,
    output reg edge_detected
);

    reg signal_prev;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            signal_prev <= 0;
            edge_detected <= 0;
        end else begin
            edge_detected <= (signal && !signal_prev);
            signal_prev <= signal;
        end
    end

endmodule

module read_from_fifo (
    input wire clk_2x,             // Doubled clock frequency
    input wire rst,                // Active high reset
    output reg rd_en,
    output reg [7:0] data_out,
    input wire fifo_empty,         // External FIFO empty signal
    input wire [7:0] fifo_dout,    // External FIFO data output
    output reg fire,               // Fire set for one clock cycle on rising edge of fire_clk
    input wire fire_clk,           // External fire signal to restart reading

    // New outputs to keep track of states
    output reg reading_state,      
    output reg [8:0] read_count_state,
    output reg fire_clk_prev_state,

    // New clock signal for external device
    output reg data_out_clk        // New clock signal for data_out
);

    reg [8:0] read_count;          // 9-bit counter to keep track of reads
    reg reading;                   // State to control reading from FIFO
    reg fire_clk_prev;             // Register to store the previous state of fire_clk
    reg fire_clk_sync;             // Synchronized fire_clk signal
    reg [2:0] delay_count;         // 3-bit counter for 5 clock cycle delay
    reg data_out_valid;            // Signal to indicate data_out is valid
    reg data_out_valid_d;          // Delayed version of data_out_valid

    reg rd_clk;                    // rd_clk generated by dividing clk_2x
    reg rd_clk_div;                // Division control for rd_clk

    // Generate rd_clk by dividing clk_2x
    always @(posedge clk_2x or posedge rst) begin
        if (rst) begin
            rd_clk <= 0;
            rd_clk_div <= 0;
        end else begin
            rd_clk_div <= ~rd_clk_div;
            if (rd_clk_div) begin
                rd_clk <= ~rd_clk;
            end
        end
    end

    // Signal for edge detection
    wire fire_clk_edge;

    // Edge detection for fire_clk
    always @(posedge clk_2x or posedge rst) begin
        if (rst) begin
            fire_clk_prev <= 0;
        end else begin
            fire_clk_prev <= fire_clk;
        end
    end

    assign fire_clk_edge = fire_clk & ~fire_clk_prev;

    // Main FIFO reading logic
    always @(posedge rd_clk or posedge rst) begin
        if (rst) begin
            data_out <= 0;
            rd_en <= 0;
            read_count <= 0;
            fire <= 0;
            reading <= 1;
            delay_count <= 0;
            data_out_valid <= 0;
        end else begin
            fire <= 0;  // Default fire to 0

            if (reading) begin
                if (!fifo_empty) begin
                    rd_en <= 1;  // Enable read
                    data_out <= fifo_dout;
                    data_out_valid <= 1;  // Indicate data_out is valid
                    read_count <= read_count + 1;
                    if (read_count == 9'd255) begin
                        read_count <= 0;  // Reset counter
                        reading <= 0;  // Stop reading
                        rd_en <= 0;  // Disable read
                        data_out_valid <= 0;  // Indicate no valid data
                    end
                end else begin
                    rd_en <= 0;  // Disable read
                    data_out_valid <= 0;  // Indicate no valid data
                end
            end else if (fire_clk_edge) begin
                fire <= 1;  // Set fire for one clock cycle
                delay_count <= 1;  // Start delay counter
            end else if (delay_count != 0) begin
                if (delay_count < 5) begin
                    delay_count <= delay_count + 1;  // Increment delay counter
                end else begin
                    delay_count <= 0;  // Reset delay counter
                    reading <= 1;  // Restart reading after 5 clock cycles
                end
            end
        end
    end

    // Generate data_out_clk based on delayed data_out_valid signal
    always @(posedge clk_2x or posedge rst) begin
        if (rst) begin
            data_out_valid_d <= 0;
            data_out_clk <= 0;
        end else begin
            data_out_valid_d <= data_out_valid;
            if (data_out_valid_d) begin
                data_out_clk <= ~data_out_clk;  // Toggle data_out_clk
            end else begin
                data_out_clk <= 0;  // Keep data_out_clk low when no valid data
            end
        end
    end

    // Update new outputs
    always @(posedge clk_2x or posedge rst) begin
        if (rst) begin
            reading_state <= 0;
            read_count_state <= 0;
            fire_clk_prev_state <= 0;
        end else begin
            reading_state <= reading;
            read_count_state <= read_count;
            fire_clk_prev_state <= fire_clk_prev;
        end
    end

endmodule
